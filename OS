운영체제

🚀 메모리영역
- 코드, 데이터, 힙, 스택
코드 - 소스코드
데이터 - 전역, static
힙 - 동적할당 받은 메모리 / 참조타입
스택 - 지역,매개변수 / 값타입 / 함수호출시 생성, 종료시 반환


🚀 빌드과정
전처리(프리프로세스) - 컴파일 - 어셈블 - 링크
- 컴파일 : 어셈블리어로 변환
- 어셈블 : 오브젝트파일로 변환
- 링크 : 실행파일로 변환


🚀 임계영역
둘 이상의 스레드가 동시에 접근해서는 안되는 공유자원에 접근하는 코드의 일부 / 지정된 시간이 지난 후 종료된다.
-> 어떤 스레드(프로세스)가 임계영역에 들어가고자 한다면 지정된 시간만큼 대기
-> 프로세스간에 공유자원을 접근하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 이용하게끔 보장 필요

🔸조건
- 상호배제 : 하나의 프로세스가 임계영역에 들어가있다면 다른프로세스는 들어갈 수 없어야 한다.
- 진행 : 임계영역에 들어간 프로세스가 없을 때 들어가려하는 프로세스가 여러개라면 하나를 결정해줘야 한다.
- 한정대기 : 다른프로세스의 기아를 방지하기 위해, 한번 임예영역에 들어간 프로세스는 다시 들어갈때 제한을 둬야한다.


🚀 데드락
- 둘 이상의 프로세스가 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고있는 자원을 요구하며 무한정 대기하는 상태

🔸데드락이 일어나는 4가지 조건
- 비선점 : 다른프로세스의 자원을 뺏을 수 없다.
- 순환대기 : 프로세스들이 서로의 자원을 기다려야한다.
- 점유대기 : 프로세스가 하나 이상의 자원을 점유한채로 다른 프로세스가 가지고있는 자원을 요구/대기한다.
- 상호배제 : 한 자원은 한번에 한 프로세스만이 사용할 수 있다.

🔸데드락 방지법
- 방지 : 교착상태가 발생할 수 있는 요구조건을 만족하지 않게 한다.
- 회피 : 교착상태가 발생할 가능성이 있는 자원할당을 하지 않는다. - 은행원알고리즘/자원할당그래프
- 탐지 및 회복 : 교착상태가 발생하도록 놔두고, 발생할 경우 찾아서 고친다.


🚀 프로세스와 쓰레드
프로세스 : 운영체제로부터 자원을 할당받은 작업의 단위 / 자신만의 고유 공간과 자원을 할당받아 사용 / 메모리상에서 실행중인 프로그램
스레드 : 프로세스 안에서 실행되는 흐름의 단위 / 다른 스레드와 공간과 자원을 공유하며 사용

프로세스 : 최소 하나의 스레드를 보유 / 각각 별도의 주소공간을 독립적으로 할당받음(코드/데이터/힙/스택)
스레드 : 스택만 따로 할당받고, 나머지 영역은 스레드끼리 서로 공유


🚀 멀티 프로세스와 멀티 스레드
- 멀티 프로세스
장점 : 하나의 프로세스가 죽어도 다른프로세스에 영향을 끼치지 않고 계속 실행
단점 : 멀티 스레드보다 많은 메모리공간 / CPU시간을 차지

- 멀티 스레드
장점 : 멀티 프로세스보다 적 메모리공간 / CPU시간을 차지
단점 : 하나의 스레드에 문제가 생기면 전체 스레드가 영향을 받으며 동기화 문제가있다.
-> 자원공유에 전역변수를 사용하므로 동기화 문제 발생 가능


🚀 멀티 스레드
- 동시성 : 싱글코어에서 멀티스레드를 동작시키기 위한 방식(코루틴) - 여러개의 스레드가 번갈아가며 실행되는것. (콘텍스트 스위칭 발생)
- 병렬성 : 멀티코어에서 멀티스레드를 동작시키기위한 방식 - 한개 이상의 스레드를 보유한 각 코어들이 동시에 실행되는것.

- 주의사항 : 다수의 스레드가 공유데이터에 동시에 접근하는 경우에 상호배제 또는 동기화 기법을 통해 동시성 문제 또는 교착상태가 발생하지 않도록 주의해야 한다.


🚀 선점형 스케줄링과 비선점형 스케줄링
- 선점형 : 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있음
- 비선점형 : 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음


🚀 세마포어와 뮤텍스
- 세마포어 : 공유된 자원의 데이터 or 임계영역에 여러 프로세스/스레드가 접근하지 못하게 하는것 (동기화대상이 여럿일때 사용)
- 뮤텍스 : 공유된 자원의 데이터 or 임계영역에 하나의 프로세스/스레드가 접근하지 못하게 하는것 (동기화대상이 하나일때 사용)
          임계구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행(상호배제)되도록 하는 기술
🔸차이점
- Mutex는 동기화 대상이 오직 1개일 때 사용하며, Semaphore는 동기화 대상이 1개 이상일 때 사용합니다.
- Mutex는 자원을 소유할 수 있고, 책임을 가지는 반면 Semaphore는 자원 소유가 불가합니다.
- Mutex는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있습니다. 
  반면 Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있습니다.
- Semaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다.
  반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 됩니다.
  
  
🚀 멀티쓰레드 프로그래밍
🔴 Locality
-기억 장치 내의 정보를 균일하게 접근하는 것이 아닌 어느 한순간에 특정 부분을 집중적으로 참조하는 특성

1. Temporal locality
최근 사용되었던 기억 장소들이 집중적으로 엑세스되는 경향.
프로그램 실행시 한번 접근이 이루어진 주소의 메모리 영역은 자주 접하게 된다는 프로그램 성격 표현.
예) 순환, Sub program, Stack 등등.

2. Spatical locality
특정 클레스터의 기억 장소들에대해 참조가 집중적으로 이루어지는 경향.
프로그램 실행시 접근하는 메모리의 영역은 이미 접근이 이루어진 영역의 근처일 확률이 높다는 프로그램 성격 표현.
예) Sequential processing, Array 등등.

🔴 메모리 배리어
- 코드 재배치 억제
- 가시성 ( 커밋 & 업데이트 )

- Full Memory Barrier (ASM MFENCE, C# Thread.MemoryBarrier) : Store/Load 둘다 막음
- Store Memory Barrier (ASM SFENCE) : Store 만 막음 ( 값 작성 : x = 1 )
- Load  Memory Barrier (ASM LFENCE) : Load 만 막음 ( 값 대입 : x = y )

🔴 Race Condition ( 경합 조건 )
- atomic = 원자성  -> 묶어서 한번에 실행 시켜야하는~ ex. 상점 구입( 템 획득 & 돈 차감 )

🔴 Lock
- 종류 : SpinLock / Context Switching / Auto Reset Event / ReaderWriterLockSlim
- SpinLock : 계속 대기하며 체크

    class SpinLock
    {
        volatile int _locked = 0;
        public void Acquire()
        {
            while (true)
            {
                // CAS : Compare And Swap
                int expected = 0;
                int desired = 1;
                if(Interlocked.CompareExchange(ref _locked, desired, expected) == expected)
                    break;
            }
        }
        public void Release()
        {
            _locked = 0;
        }
    }

- Context Switching
Thread.Sleep(1);  => 무조건 휴식
Thread.Sleep(0);  => 조건부 양보 - 우선순위가 낮은 쓰레드한테는 양보 불가
Thread.Yield( );    => 관대한 양보 - 실행가능한 쓰레드가 있으면 양보

- AutoResetEvent

        AutoResetEvent _available = new AutoResetEvent(true);
        public void Acquire()
        {
            _available.WaitOne();
        }
        public void Release()
        {
            _available.Set();
        }


- 상호배제 => Monitor.Enter(obj) - Monitor.Exit(obj)
   -> Enter만 하고 Exit하지 않는경우 DeadLock 발생
   -> lock() { } 사용하면 Exit 자동

🔴 Thread Local Storage
TLS의 필요성을 살펴보자, 게임서버 같은 경우에는 락이 여러군데에 존재한다. 
그 이유는 쓰레드와 태스크를 일대일로 잘 배분했다 하더라도 
쓰레드가 하나의 태스크에 몰리게 되는 상황이 생겨날 수 있을 것이다. 
이러한 경우 충돌이 일어나기 때문에 lock을 걸기 위해 mutex가 존재하게 된다. 
이 경우 경합에서 지게되는 쓰레드들은 모두 대기 상태로 들어가기 때문에 
쓰레드가 일을 하지 못하게 되는 문제가 발생하게 된다. 
이것을 막기 위해 우리는 TLS를 사용한다.

💎 TLS란?
TLS는 쓰레드가 각각 가지고 있는 저장소이다.
이 곳에 저장되는 값들은 전역변수 이지만, 
한 쓰레드 내에서만 유효한 전역 변수이다. 
이러한 면에서 Stack과는 차이가 있다.
그래서 이 TLS을 이용해서 쓰레드가 집중된 task를 빠르게 처리하는가? 하면, 
공유하는 영역인 Heap, 데이터 영역의 값을 사용 할 만큼 큼직하게 잘라서 TLS로 가져온다. 
이 과정만 하기 때문에 부하가 크지는 않을 것이다. 
이렇게 공유영역에서 가져온 값을 TLS로 옮기면 그 이후에 mutex를 차지하기 위한 경합이 일어나지 않을 것이다. 
  
  
  
  
  
  
