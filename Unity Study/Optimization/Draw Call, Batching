- 드로우콜, 배칭

⨀ 드로우콜
- CPU가 GPU에게 렌더링하라고 명령을 보내는 것이다.
- 대부분 병목의 원인이 드로우콜에 있다.

ο 과정
CPU가 HDD, SDD, SD 카드 등의 스토리지에서 파일을 읽어들이고 
데이터를 파싱하여 CPU 메모리에 데이터를 올린다.
그 후 CPU 메모리의 데이터를 GPU 메모리로 복사하는 과정을 거친다. 

ο Command Buffer
CPU가 GPU에게 명령을 바로 주지 않고 중간에 한 단계를 거친다. 
바로 준다면 GPU가 다른 작업을 수행하고 있을때 CPU는 GPU가 하던일을
마칠 때까지 기다려야하는 불상사가 생길 것이다. 
그래서 CPU는 명령을 버퍼에 쌓아놓고, 
GPU는 버퍼에서 명령을 가져가서 할 일을 하는 방식으로 일한다. (병렬식)
이렇게 일을 쌓아두는 버퍼를 Command Buffer라고 부른다.
커맨드 버퍼는 FIFO(First In First Out) 방식으로 명령을 처리한다.

ο Unity 에서의 Command Buffer
원래 그래픽스의 커맨드버퍼는 low-level 이지만, (단순한 명령)
유니티의 커맨드버퍼는 high-level로 빌트인 렌더 파이프라인을 확장할 수 있다. (명령 목록)
커맨드 버퍼가 실행할 Unity 빌트인 렌더 파이프라인의 포지션을 지정하려면 CameraEvent 열거형을 사용하면 된다.

ο Draw Call은 CPU 바운드의 병목
문제는 CPU가 명령한 것이 GPU에서 사용하는 신호로 변환되어야한다는 것인데, 이는 결국 CPU에게 부담이 된다.
그래픽스 API들은 CPU에서 GPU로 보내는 명령을 공통적인 API로 구성한다.
API가 호출되면 드라이버 칩셋에 알맞은 신호를 전달하여 GPU에 맞게 명령을 변형하는 과정을 거친다.
이 과정을 거치기 때문에 CPU가 GPU에게 명령을 보낼 때 
오버헤드(정보 처리를 위한 간접적인 처리 시간)가 발생한다. 
그래서 드로우콜은 CPU 바운더리의 오버헤드이다.

ο Draw Call 발생 조건
기본적으로 오브젝트를 하나 그릴 때 Mesh 1개, Material 1개라면 드로우콜이 한 번 발생한다. 즉, Batch가 1이 된다.
하지만 오브젝트 하나가 메시 여러개로 구성되어있는 경우, 메시가 17개라면 드로우콜도 17번 발생한다.
이 메시들이 1개의 메테리얼을 공유하더라도 메시 개수 대로 17번의 드로우 콜이 필요하다.
반대로 하나의 메시에 메테리얼이 여러 개여도 그 개수만큼의 드로우 콜이 필요하다.
쉐이더에 의해서도 드로우 콜이 늘어날 수 있다. 쉐이더 내에서는 멀티 패스(Multi Pass)라고,
두 번 이상 렌더링을 거치는 경우가 존재한다. 대표적인 예가 카툰 렌더링이다. 
첫번째 패스에서 모델을 렌더링하고, 두번째 패스에서 모델 외곽선을 그려준다. 
렌더링을 두 번 해야하므로 드로우 콜이 두 번, Batch도 두 번 이다.
따라서 메시가 하나, 메테리얼이 하나라고해서 반드시 하나의 드로우 콜만 발생하는 것이 아니다. 
특히 모바일의 경우 드로우콜 횟수가 크면 성능에 많은 영향을 끼칠 수 있으므로 드로우 콜을 신경쓰면서 최대한 줄여야한다.

ο Batch
DP Call과 상태 변경들을 합친 넓은 의미의 드로우 콜.
만약 Batch가 10번, SetPass가 1번 발생했다면 10번의 드로우 콜 동안 쉐이더의 변경은 없었고,
메시 및 트랜스 폼 정보 등 최소한의 상태 변경만 이뤄졌다는 것을 의미한다.
SetPass도 10번 일어났나면 10번의 드로우 콜 마다 매번 쉐이더의 변경이 이뤄졌고,
경우에 따라 많은 상태 변경이 일어났다는 것을 의미한다. 당연히 이 경우가 성능을 더 많이 잡아먹을 것이다.

ο SetPass
SetPass는 쉐이더로 인한 렌더링 패스 횟수를 의미한다.
SetPass에서 알려주는 상태 변경은 쉐이더의 변경 혹은 쉐이더 파라미터들의 변경이 일어나는 경우.
씬 오브젝트를 렌더링하는 과정에서 메테리얼이 바뀌면 그에 따라 쉐이더 및 파라미터들이 바뀌고 SetPass 카운트가 증가한다.
이 때 많은 상태 변경이 일어나야 하기 때문에 SetPass 횟수도 중요하다.
만약 게임이 CPU 바운드이고 GPU에 명령을 보내는 과정, 
즉 드로우콜이 병목이라면 SetPass call 횟수를 줄이는게 가장 효율적이다.
서로 다른 메시를 사용한다고 SetPass call이 늘어나는 것은 아님. 
다른 메시라도 같은 메테리얼을 쓰면 늘어나지 않음.
10개의 오브젝트가 서로 다른 메시여도 같은 메테리얼을 쓴다면 Batch는 10번 발생해도 SetPass는 1번만 발생한다.
이렇게 SetPass call이 적으면 Batch 구성이 잘 되어있는 것.


⨀ Batching
- 드로우 콜을 줄이는 작업.
- Static Batching, Dynamic Batching 두 종류가 있다. 

ο 설명
유니티에서 배칭을 활용함으로써 드로우 콜을 많이 줄일 수 있기 때문에 거의 필수적으로 사용해야하는 기능.
여러 Batch를 묶어서 하나의 Batch로 만드는 것을 Batching이라고 한다.
즉 Batching은 여러 번 드로우 콜 할 상황을 하나의 드로우 콜로 묶는 과정이다.

다른 오브젝트, 메시를 사용하더라도 메테리얼이 같다면 하나의 Batch로 구성할 수 있다.
여러 개의 다른 오브젝트들이지만 메테리얼이 같다면 배칭처리를 통해 한 번에 그리는 것이 가능하다는 얘기이다.

같은 텍스쳐, 같은 쉐이더를 이용한 메테리얼이더라도 따로 두개를 만들어 두면
그 두 개는 다른 메테리얼로 인식, 배칭이 되지 않는다. 
스크립트에서 메테리얼에 접근할 때도 이런 이유에서 조심해야할 것이 있다. 
GetComponent<Renderer>().material.color = Color.red;
이렇게 메테리얼의 속성을 수정하면 메테리얼이 수정되는 것이 아니라 메테리얼의 복사본이 생성된다.
대신 Renderer.sharedMaterial로 수정하면 복사본이 생성되지 않고 공유된 메테리얼 원본을 수정한다.
이 경우 공유하고 있던 다른 오브젝트들도 수정된 결과가 적용되니 인지하고 유의해서 사용하자

배칭을 하기 위해서는 하나의 메테리얼을 여러 메시들이 공유해서 사용해야한다.
즉 텍스쳐 하나를 공유해서 사용해야한다는 뜻.
그래서 텍스쳐 하나에다가 여러 개의 텍스쳐를 합쳐서 사용하는 
텍스쳐 아틀라스(Texture Atlas) 기법으로 리소스가 제작된다.

2D에서는 스프라이트 아틀라스(Sprite Atlas)를 사용한다. 
->  Static Batching이나 Dynamic Batching처럼 체크하지 않아도 자동으로 배칭이 이뤄진다.
    텍스처 아틀라스와 같은 기법으로 스프라이트들을 하나의 이미지에 모아 넣는 스프라이트 시트로 많이 제작된다.
    스프라이트 시트는 개별 이미지를 차례로 재생하여 애니메이션을 만들 수 있다.

ο Static Batching
- 정적인 오브젝트를 위한 배칭 기법. 주로 배경 오브젝트들이 해당된다.
- Static Batching을 적용할 오브젝트라면 인스펙터에서 Static을 체크해줘야 한다.
  이걸 켜주면 스태틱 배칭의 대상으로 인정받아 로딩타임에서 자동으로 배칭처리가 될 것이다.
- 다이나믹 배칭보다 효율적이다. 런타임에서 수행할 버텍스 연산이 없기 때문이다.
- 로딩타임에서 배칭처리를 하기 때문에 처음부터 씬에 존재해야 스태틱 배칭에 껴준다.

- 주의할 점
  메모리와 저장에 오버헤드를 발생시킬 수 있다.
  메모리가 추가로 필요하다. 다른 메시들을 메테리얼이 같다는 이유로 한 번에 그리는 것이다.
  따라서 배칭처리를 하면 오브젝트들을 합쳐서 내부적으로 하나의 메시로 만들어 놓는데,
  1개의 메시만 사용하더라도 여러 개의 메시를 합친, 거대한 메시를 만들기 위한 추가 메모리가 필요한 것이다.
  이렇게 새로 만들어낸 메시를 GPU가 가져가서 그대로 화면에 렌더링하므로 드로우 콜은 1번에 처리될 수 있던 것.
  추가적으로 메모리를 희생하더라도 드로우 콜을 줄일 수 있기 때문에 런타임 성능을 높일 수 있다.

ο Dynamic Batching
- Static이 체크되지 않은 동적인 오브젝트들 중 동일한 메테리얼을 사용하고
  특정 조건을 만족하는 오브젝트들을 대상으로 배칭처리를 하는 기능.
  Dynamic Batching을 체크해주면 별로의 추가 작업이 필요하지 않고 알아서 해준다.

- 주의할 점
  CPU 오버헤드 발생를 발생시킬 수 있다.
  매 프레임 씬에서 동적인 오브젝트들의 버텍스를 모아서 합쳐주는 과정을 거친다.
  모은 버텍스들을 다이나믹 배칭에 쓰이는 버텍스 버퍼와 인덱스 버퍼에 담으면 GPU가 이것을 가져가서 렌더링한다.
  결과적으로 매번 데이터 구축과 갱신이 발생하기 때문에 매 프레임마다 오버헤드가 발생한다.
  일반적으로 렌더링 할 때는 버텍스 쉐이더에서 월드스페이스로 변환하는 과정에서 GPU에서 고속연산이 이뤄지는데,
  다이나믹 배칭을 위해서는 오브젝트의 버텍스를 월드스페이스로 변환하는 연산이 CPU에서 이뤄진다.
  따라서 이 연산과정이 드로우 콜보다 시간이 오래걸리면 오히려 효율이 떨어지는 것이다.
  배칭 오버헤드와 드로우 콜 시간을 비교하여 더 빠른 쪽으로 하는 것이 맞다.
