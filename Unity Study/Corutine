- Corutine

⨀ 특징
- 특정 위치에서 실행을 일시 중단하고 다시 시작할 수 있는 여러 진입점을 허용한다.
- 비선점 멀티 태스킹을 위해 서브루틴을 일반화하는 프로그램의 구성 요소다.
- Thread Safe를 보장하진 않는다. (따로 구현해야 한다.)
- 처리 도중 취소가 가능하다.
- 반환형은 IEnumerator -> 한 개 이상의 yield 반환문을 포함해야 한다. 
- yield로 반환하는 것은 '일시적으로 CPU 권한을 다른 함수에 위임한다'라는 뜻이다.
- WaitForSeconds waitSec = new WaitForSeconds(1); 이런식으로 new를 매번 처리하지않게끔.
- StartCoroutine할때 마다 가비지가 생성되므로, 되도록 여러번 호출하지 말고
   ------------------------------------------------------
  || yield return new WaitUntil(() => Unit.isActivate); ||
  || -> Unit.isActivate가 true가 될때까지 대기한다.       ||
   ------------------------------------------------------
  위와 같은 방식으로 멈춰놓자.


⨀ 목적
하나의 스레드에서 오랫동안 처리되는 작업을 진행하면 스레드가 대기 상태가 된다. 
대기 상태에 있는 스레드를 다른 작업을 할 수 있도록 활용하기 위해 사용된다.

⨀ 스레드와의 차이점
- 스레드의 경우 여러 개의 스레드를 사용해서 여러 개의 작업을 '병렬'로 수행하여 비동기적으로 작동한다.
하지만 코루틴의 경우 비동기 작업에 사용되긴 하지만 실제로는 병렬적으로 수행되는 것이 아니고
여러 개의 작업을 잘게 쪼개서 나눠서 작업을 수행하는 방식이다.(동시성 처리)

- 둘의 공통점은 프로그램을 만드는 과정에서 '비동기' 작업을 하기 위해서 사용한다는 점이다.
비동기 작업은 어떤 작업을 수행할 때, 이가 끝나는 것을 기다리지 않고 다른 작업을 수행하는 것이고
반대로 동기 작업은 해당 작업이 끝날 때까지 기다린 뒤 다음 작업을 수행하는 것이다.

- 유니티는 단일 쓰레드의 원리로 동작한다. 
Coroutine 기능으로 멀티 쓰레드의 기능을 하게 해준다.(멀티 쓰레드가 된다는 것은 아니다.)
다른 쓰레드를 사용하지 않고 멀티 태스킹을 가능하게 해주는데
이는 코루틴 함수가 IEnumerator를 반환 하는 점으로부터 접근할 수 있다.

- 멀티쓰레드가 가지는 교착 상태 경합 등의 문제에서 자유롭다는 장점이있다.

⨀ Invoke와의 차이점

코루틴
- Game Object가 Inactive(Active가 false)일 경우에는 동작하지 않는다.
- 매개변수를 가질 수 있다.      

Invoke
- Game Object의 Active 상태에 상관없이 동작한다.
- 매개변수를 가질 수 없다.
