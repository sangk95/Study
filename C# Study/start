* Heap
▶ 위치가 정해져 있지 않고 용량이 큰 대신 느림

▶ 참조 타입 ( ex class, string, object )

▶ 변수 선언 시 데이터가 저장되어있는 메모리를 가리키게 됨

* Stack
▶ 정렬되어 있고 빠르지만 사용에 제한이 있음

▶ 값 타입 ( int, char, float, enum, struct )

▶ 변수 선언시 데이터가 있는 메모리 반환

* Static
▶ .net에서 static 변수는 High Frequency Heap이라 불리는 특별한 힙에 저장됨

▶ static 클래스는 객체 인스턴스화를 하지 않는 클래스 이기 때문에 static 클래스의 객체를 생성할 수 없음 


///////////////////카비지 컬렉터///////////////////

GC ( 가비지 컬렉션 )의 동작 원리

1. C# 메모리 할당

- C#은 선형적인 Heap 메모리를 가지고 있으며, 메모리 할당을 위한 포인터 만을 가지고 있음

- 메모리 할당이 필요한 경우 현재 필요한 메모리 크기만큼 증가시키고 0세대값으로 설정. 포인터는 증가된 크기만큼 이동 시킴 

- 할당을 위한 충분한 메모리가 없을 경우, GC가 호출되고 GC가 호출됨에도 충분한 메모리가 없을 경우에는 Heap메모리가 확장 됨. 대부분의 Unity 플램폼의 경우 힙의 크기를 2배로 늘림

- 만일 사용 가능한 메모리 공간이 부족해지는 경우 앱이 강제 종료 됨


2. C# 메모리 해제

- GC 는 시스템의 실제 메모리가 부족 하거나, Managed Heap에 할당된 개체에 사용되는 메모리가 허용되는 임계 값을 넘었을 때, GC.Collect 메서드가 호출 될 때 발생

- GC는 힙 메모리 상에서 사용 중인 객체들의 참조 그래프를 가지고 있으며, 이를 통해 현재 사용 중이지 않은 메모리를 해제하고 사용 중인 메모리는 재배치를 하게 됨

- 참조 그래프의 Root는 Stack에 있는 로벌 켠수, 정적 빌드, 전역 변수 등이 되고, 하위는 객체 간의 참조가 될 수 있음


- 세대별 가비지 컬렉션

: 최근에 할당된 메모리부터 GC가 한번 불릴 때마다 살아 남은 메모리까지 0 ~ 2 세대까지 분리

: 최근에 생성될 객체일 수록 메모리 해제가 발생할 가능성이 높기 때문에 0 세대의 메모리 부터 관리

: 0세대의 GC에서 남아 있는 메모리는 1세대로 변경 됨, 1세대의 GC가 발생하고 남이 있는 1세대는 2세대로 변경 됨

: 0 세대의 메모리 관리 후에도 메모리가 부족해지면 1세대 -> 2세대 순으로 메모리를 관리


///////////////////코루틴///////////////////

🚀 Coroutine(코루틴)과 Thread(쓰레드)
닷넷(.NET)은 멀티 쓰레드를 지원한다. 하지만 닷넷(.NET)을 사용하는 유니티는 단일 쓰레드의 원리로 동작한다. 
멀티쓰레드의 코드는 쓰레드간 교착 상태 등을 신경써야 하며 버그 발생률이 높아진다.
그런데 단일 쓰레드의 원리로 동작하는 유니티에선 Coroutine 기능으로 멀티 쓰레드의 기능을 하게 해준다.(멀티 쓰레드가 된다는 것은 아니다.)
다른 쓰레드를 사용하지 않고 멀티 태스킹을 가능하게 해주는데 이는 코루틴 함수가 IEnumerator를 반환 하는 점으로부터 접근할 수 있다.

🚀 Coroutine(코루틴)과 서브루틴(Subroutine)
일반적으로 우리가 사용하는 함수는 진입하는 지점은 하나 존재하고 함수가 종료하는 시점은 코드가 모두 실행되거나, return 구문에 의해서 종료되는 지점을 설정할 수 있습니다.
이러한 함수를 우리는 서브루틴(Subroutine)이라 하는데 코루틴(Coroutine)은 이를 더 일반화 한 개념으로 진입하는 지점 마저 여러개를 설정할 수 있는 함수를 의미한다.

🚀 IEnumerator란?
IEnumerator는 우리말로 "열거자"라고 한다. 데이터의 목록을 하나씩 넘겨줄 때 사용되는 인터페이스이다. 코루틴은 호출한 함수와 서로 상호작용하면서 진행하도록 설계되어 있다.
자신을 호출한 함수에게 데이터를 하나 넘겨주고 쉰 다음 호출한 함수에서는 데이터를 받고 나서 처리 후 다음 데이터를 받아야 할 때 쉬고 있던 코루틴이 일어나서
다시 데이터를 전달하는 것을 반복하는 구조로 동작한다는 것이다.
이를 위해서 데이터를 전달한 후 코루틴은 대기할 때 C#에서는 yield return을 사용한다.


/////////////////// JSON ///////////////////
1. JSON 이란?
JSON(제이슨, JavaScript Object Notation)은 이름과 값으로 이루어진 데이터 오브젝트로, 웹이나 네트워크에서 데이터를 주고 받을 때 사용하는 개방형 표준 포멧입니다.
JSON 데이터는 텍스트로 되어 있어 읽기 쉽다는 장점을 가지고 있고, 내용을 함축적으로 최소의 정보만을 사용하기 때문에, XML에 비해 용량이 작고, 속도도 빠릅니다.

JSON 데이터 기본 형태는 데이터명, 클론(:), 값 순서로 구성되어 있습니다.
ex) "데이터명":값

데이터명과 문자열은 ""(큰 따음표)로 감싸야 합니다.
ex) "name":"Coderzero"

JSON 객체는 {}(중괄호)로 둘러 쌓으면 되고, 각 프로퍼티는 ,(쉼표)로 분리합니다.
ex)
{
    "name": "coderzero",
    "age": 48,
    "height": 172.1,
    "man": true,
    "description": null
}

JSON 배열은 [](대괄호)를 사용하여 묶습니다.
그리고, ,(쉼표)를 사용하여 분리합니다
ex)
"coder":[
    {"name":"coderzero", "age":48, "height": 172.1},
    {"name":"coderone", "age":8, "height": 102.1}
]


///////////////////오브젝트 풀링///////////////////
1. 오브젝트 풀링(Object pooling)

오브젝트 풀링은 개체를 할당하고 파괴하는 대신, 미리 오브젝트 집합(Object Pool)을 생성하고, 필요할 때에 불러와 사용하고,
사용한 개체를 다시 개체 집합에 반환하여, 개체들을 재사용하는 디자인 패턴 중의 하나이다.    

오브젝트 풀링은 미리 생성된 개체를 재사용하므로 개체를 생성하고, 파괴하는데 드는 시간 및 비용의 낭비를 줄일 수 있다.
오브젝트의 생성 및 파괴는 자원의 낭비가 심하다. 게다가, 오브젝트의 파괴는 가비지 컬렉션(Garbage Collection )을 호출하게 된다.
가비지 컬렉션은 시스템에서 자동으로 호출되며, 수집 과정은 상당한 CPU 시간을 요구한다.
최적화와 관련된 글을 접하게 되면 자주 언급되는 것이 가비지 컬렉션이다. 
메모리를 효율적으로 관리하지만, 이 역시 프로그램이 실행되고, 해제가 될 때까지 지속적으로 자원을 사용한다.
한 번만 사용하는 오브젝트는 Destroy()를 호출하여 파괴를 하면 된다.
하지만 여러 번 반복적으로 사용하게 되는 오브젝트는 오브젝트 풀링을 사용하는 것이 최적화에 좋다. 
유니티는 총알, 스킬 이펙트와 같은 반복적으로 사용하는 오브젝트는 오브젝트 풀링을 사용하여, 
오브젝트를 재사용하여 메모리를 효율적으로 관리하도록 권장하고 있다(유니티 문서).
오브젝트 풀링은 미리 오브젝트 집합을 생성하여, 메모리를 할당하기 때문에,
오브젝트를 파괴하는 것보다 메모리를 더 많이 사용하는 단점이 존재한다. 
오브젝트 풀링은 오브젝트를 파괴하지 않고, 오브젝트를 보이지 않게 할 뿐 메모리에서 해제하는 것은 아니다.
오브젝트 풀링 디자인 패턴은, 사용 가능한 오브젝트 집합, 사용 중인 오브젝트 집합, 두 개의 오브젝트 집합을 사용하여 구현한다.
오브젝트 풀링을 간단하게 요약하면 재사용이다. 본 글에서는 오브젝트 집합을 생성하고 이를 재사용하는 것에 초점을 맞추어 구현한다.
