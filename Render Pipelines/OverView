렌더링 파이프라인
- GPU를 사용하여 리소스를 2D이미지로 렌더링 하는 과정

1. 입력조립기
- 메모리에서 기하자료를 읽어서 기본 도형을 조립


2. 버텍스 셰이더
- 물체의 정점 정보에 수학적인 연산을 하여 물체에 특별한 효과를 주는데 쓰임
- 정점정보 : 좌표 / 색상 / 텍스쳐 / 조명정보
- 정점정보의 값을 변화시키는 일을 한다.
--> 정보 삭제/추가는 불가능
🔴공간 변환 과정
공간 변환은 각각의 행렬 연산을 통해 이루어진다.
변환 행렬은 총 3가지로, 각각 Model, View, Projection이다.
M, V, P는 각각 변환 행렬 이름이기도 하고, 변환 자체를 가리키기도 한다.
⭕M (Model)
오브젝트 공간(Model Space, Object Space) -> 월드 공간(World Space)

각 오브젝트마다 자신의 피벗 위치를 원점(0, 0, 0)으로 하는 좌표 공간을 갖고 있다.
게임 내의 월드는 단 하나의 위치를 원점으로 하는 좌표 공간을 갖고 있다.
모델 변환은 각 오브젝트의 좌표 공간을 변환하여 하나의 월드 공간에 통합하는 과정이다.

이 과정에서 이동(Translate), 회전(Rotate), 크기(Scale) 변환이 이루어진다.
이 세가지 변환은 각각 행렬을 통해 수행되고, 이를 하나의 행렬로 만든 것을 TRS 행렬이라고 한다.

TRS 행렬은 좌측부터 우측으로 S, R, T 순서로 곱해진다.
그리고 벡터와 곱할 때 벡터가 우측에 온다.
따라서 각각 따로 곱할 때는 행렬을 좌측에 놓고 T, R, S 순서로 곱한다.


⭕V (View)
월드 공간(World Space) -> 카메라 공간(View Space)

카메라 공간은 카메라의 위치가 원점(0, 0, 0)이고, 카메라가 바라보는 방향이 +Z축인 공간을 의미한다.
뷰 변환은 모든 오브젝트를 화면에 그려내기 쉽도록 카메라 기준으로 공간을 변환하는 과정이다.


⭕P (Projection)
카메라 공간(View Space) -> 클립 공간(Clip Space)

카메라 기준의 정점 위치를 화면에 보이기 위한 정점 위치로 변환한다.

화면에 렌더링될 수 있는 영역을 나타내는 절두체(Frustum)가 정의된다.
절두체는 Near Clipping Plane, Far Clipping Plane, Field of View를 통해 정의한다.

절두체를 완전히 벗어나는 폴리곤들은 모두 버려지고
절두체의 경계에 걸쳐 있는 폴리곤들은 일단 유지한다.

원근감이 없는 직교 투영(Orthographic Projection) 또는
원근감이 있는 원근 투영(Perspective Projection)이 행해진다.

클립 공간의 좌표계는 사실 3D가 아닌 4D이다.
클립 공간의 모든 X, Y 좌표는 -1 ~ 1 범위에 존재하며,
Z 좌표는 0 ~ 1 범위에 존재한다.
W 값은 카메라에서 멀수록 커지며, 추후 🔆NDC로의 변환에 사용된다.

클립 공간의 4D 좌표계를 동차 좌표계(Homogeneous Coordinates)라고 한다.

보통 클립 공간과 NDC를 혼용하는 경우가 많은데,
엄밀히 말하자면 버텍스 쉐이더의 최종 출력은 클립 공간의 정점 데이터이다.

🔆NDC
  - X, Y 좌표는 모두 -1 ~ 1, Z 좌표는 0 ~ 1에 위치하는 좌표계
  - 스크린 좌표로 손쉽게 변환할 수 있도록 하기 위한 3D 공간 변환 상의 마지막 좌표계
  - 클립 스페이스의 (x, y, z)를 w로 나눈 결과이다.



3. 테셀레이션
- 주어진 메시의 삼각형을 더 잘게 쪼개 새로운 삼각형을 만들어내는 과정
- 새 삼각형들은 원래 없던 세부적 특징을 만들어 낼 수 있다.
장점
- 가까운 삼각형의 세부도를 높이고, 거리에 따라 디테일 정도를 조절하는 LOD구현 가능
- 메모리에 로우폴리 메시를 담아 메모리를 절약하고, 필요할때만 즉석으로 세분화하여 메모리를 효율적으로 관리 
- 애니메이션의 계산량을 줄일 수 있다.


4. 지오메트리 셰이더
- 하나의 기본도형을 입력받아 그것을 임의로 변환하는 셰이더
- 버텍스셰이더에서 처리한 기하구조를 GPU에서 추가적으로 생성/파괴 가능
- 점, 선분을 사각형으로 확장하는 일에 사용된다.


5. 레스터라이저
- 화면을 출력할때 필요한 픽셀의 색상을 계산하는 과정
- 버텍스셰이더로부터 전달받은 정점의 색들을 보간하여 픽셀을 채워준다.
- 하드웨어 자체 알고리즘을 통해 동작
- 프로그래밍이 불가능한, 고정 파이프라인 단계
⭕역할
  1. 클리핑 : 버텍스 셰이더 후 절두체 경계에 걸쳐있는 폴리곤을 잘라내어, 절두체 내부와 외부 영역을 분리하여 외부 영역을 버림
  2. 원근 분할 : 원근법 구현 완료된 상태(클립스페이스 좌표를 이용) -> 원근분할 마친 좌표계 = *NDC
  3. 후면 컬링 : view벡터와 normal벡터의 관계를 통해 후면을 찾아내어 렌더링되지 않도록 면을 제거
  4. 뷰포트 변환
    - 3D NDC 공간 상의 좌표를 2D 스크린 좌표로 변환한다.
    - -1 ~ 1 범위였던 (X, Y) 좌표를 화면 해상도 범위로 변환한다.
    - 2D 공간으로 변환한다고 하지만, 실제로는 Z값을 깊이 값으로 사용하기 위해 그대로 유지한다.
  5. 스캔변환
    - 프리미티브(기본 도형, 삼각형 등)를 통해 프래그먼트를 생성하고, 🔆프래그먼트를 채우는 픽셀들을 찾아낸다.
    - 각 픽셀마다 정점 데이터(위치, 색상, 노멀, UV)들을 보간하여 할당한다.

🔆프래그먼트 : 픽셀 하나의 색상을 화면에 그려내기 위한 정보를 담고 있는 데이터

  
6. 필셀 셰이더 (프래그먼트 셰이더)
- 각 픽셀에 대해 수행되는 셰이더
- 조명, 반사, 그림자효과 등 더 복잡한 작업을 수행한다.
- 깊이 값은 Z-Buffer에, 색상 값은 Color Buffer에 저장된다. 이런 버퍼들을 통칭하여 스크린 버퍼(Screen Buffer)라고 한다.
- 연산 수가 버텍스셰이더보다 훨씬 많기때문에 웬만하면 버텍스셰이더에서 처리하는것이 유리하다.


7. 출력 병합기
- 픽셀셰이더가 생성한 데이터가 입력되며, 일부 픽셀 단편들이 폐기될 수 있다.
- 폐기되지 않은 픽셀 단편들은 백버퍼에 기록되며 blending도 이 단계에서 일어난다.
